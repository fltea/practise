<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <!-- <div id="app" style="color: red;font-size: 20px">hello {{ msg }} <h1>kewq</h1>{{ list }} </div> -->
  <div id="app">
    <my-button></my-button>
    <my-button></my-button>
  </div>
  <!-- <div id="epp"></div> -->
  <script src="dist/vue.js"></script>
  <script>
    // umd Vue
    // console.log(Vue)
    // 響應式 vue2 mvvm

    // Vue.Mixin({
    //   created(){
    //     console.log('mixin created')
    //   }
    // })
    // Vue.Mixin({
    //   created(){
    //     console.log('mixin created 2')
    //   }
    // })
    // Vue.Mixin({
    //   created(){
    //     console.log('mixin created 3')
    //   }
    // })
    Vue.component('my-button', {
      template: '<button>組件mybutton</button>'
    })
    const vm = new Vue({
      el:'#app',
      data() {
        // console.log(this)
        return {
          msg: 'dfdf',
          msg1: 'dfdf',
          a: {
            b: 20,
          },
          list: [1,2,4],
          newsl: [{a:2}]
        }
      },
      // components: { myButton },
      // computed:{
      //   msgStr(){
      //     const { msg1, msg } = this
      //     return (msg1.indexOf('ms') > -1 ? 'MSSSSS' : msg1) + msg;
      //   }
      // },
      // created(){
      //   // console.log('created 343dfgfkgj lfgk 454545')
      // },
      // updated(){
      //   // console.log('updated 343dfgfkgj lfgk 454545')
      // },
      // watch: {
      //   // msg(nv,ov){
      //   //   console.log(nv)
      //   // }
      //   'a.b': {
      //     handler(v2,v3) {
      //       // console.log('flash handler', this, v2,v3 )
      //     },
      //     immediate: true,
      //   }
      // },
      // methods: {
      //   flash(){
      //     console.log(this, 'flash')
      //   }
      // }
    })

    // 實例獲取 computed 屬性 通過 Object.defineProperty
    // console.log(vm.msgStr)
    // 緩存機製
    // setTimeout(() => {
    //   vm.msg1 = 'ms'
    // }, 1000)

    // console.log(vm._data.a = {c:30})
    // console.log(vm._data.list.push(100))
    // console.log(vm._data.newsl.push({b: 2020}))
    // console.log(vm.newsl.push({b: 2020}))

    // 初次渲染 ===> 初始化數據 ===> 模版編譯 ===> 變成 render() ===> 生成虛擬節點 ===> 變成真實 DOM ===> 放到頁面

    // 模版編譯 template render el(必須存在) render() template 

    // vue 生命週期  實現原理 源碼實現
    // Vue.mixin({  })  混入
    // 設計模式 訂閱發佈  vue options{data:[],watch:[]}

    // setTimeout(() => {  // nextTick
    //   // vm.msg = '數據變化'
    //   // vm.list.push(34)
    //   vm.a.b = 333
    // }, 1000);
    // vm.$nextTick(() => {
    //   console.log('nextTick', vm.$el.innerHTML)
    // })
    // 數據變化 vm._update(vm._render())
    //  vue 中更新組件策略是 以組件為單位，個每一個組件添加一個 watcher ，屬性變化後，調用者 watcher

    // 實現對象收集依賴
    // dep 和 watcher 關係 多對多  computed

    // 數組收集
    // 給所有對象類型增加一個 dep [] 
    // 獲取數組的值，會調用 get 方法，希望讓當前數組渲染的 watcher
        // 需要獲取到當前 dep
        // 數組取值時，數組的 dep 記住這個 watcher
        // 數組更新時， 找到這個 watcher 進行更新 

    //  vue 操作 vnode {tag:'div', data:{}}
    // 真實 DOM 屬性
    //   console.log(epp)
    // for(let kye in epp) {
    //   console.log(kye)
    // }

    // vue diff 算法 最小量更新 （比對） old new
    // 創建倆個 vnode
    // 比對： 在數據更新的時候， 拿到老的節點和新的節點作對比 將不同的地方進行更新
  </script>
</body>
</html>