# TS 繼承

1. 練就更深厚的 JS 原型，原型鏈功底，為面試、閱讀 Vue3 / React 源碼或其他流行框架源碼鋪路
2. 提升前端項目架構的根基技術 【工具庫、組件庫 ==> TS 開發，運用 TS 繼承，多態等技術寫高水平代碼】
3. 突破前端技術瓶頸之一的技能，晉級中、高級前端工程師必會技能

## 深度掌握 TS 繼承準備 -- 原型鏈繼承

原型鏈繼承實現的本質是改變 Son 構造函數的原型對象變量的指向【就是 Son.prototype 的指向】，Son.prototype = new Parent() 。那麼 Son.prototype 可以訪問 Parent 對象空間的屬性和方法。 所以順著 __proto __ 屬性，Son 類也可以 訪問 Parent 類的原型對象空間中的所有屬性和方法。

> 原型鏈繼承查找屬性和方法的完整路線描述： 子對象首先在自己的對象空間中查找要訪問的屬性或方法，如果找到就輸出，如果沒有找到，就沿著子對象中的 __proto __ 屬性指向的原型對象空間中去查找有沒有這個屬性或方法，如果找到就輸出，如果沒找到，繼續沿著原型對象空間中的 __ proto __ 查找上一級原型對象空間中的屬性或方法，直到找到 Object.prototype 原型對象屬性指向的原型對象空間為止，如果再找不到，就輸出 null 。

### 原型鏈繼承容易遺忘的一步

``` js
Son.prototype.constructor = Son
// 讓 Son 類的對象或函數原型.prototype 指向的原型對象空間【 new Parent() 對象空間 】有一個 
// constructor 指向了 Son 構造函數對象空間
```

### Son.prototype = Parent.prototype 可以嗎？

Son.prototype = Parent.prototype
Son.prototype.constructor = Son
執行後會讓 Son.prototype 和 Parent.prototype 和 son2.__proto __ 指向的原型對象空間 [ Parent.prototype 指向的原型對象空間 ]  指向 Son 構造函數對象空間
違背了 Parent 原型對象空間的 constructor 屬性必須指向 Parent 自身的構造函數

### 原型鏈繼承的不足

局限性： 不能通過子類構造函數想父類構造函數傳遞參數


## 深度掌握 TS 繼承準備 -- 借用構造函數（冒充對象繼承）

### 借用構造函數繼承如何解決原型鏈集成的局限性

借用構造函數繼承思想就是在子類的內部借助 apply() 和 call() 方法調用並傳遞參數給父類，在父類構造函數中為當前的子類對象變量增加屬性

### 借用構造函數繼承的不足

借用構造函數實現了子類構造函數相符類構造函數傳遞參數，但沒有繼承父類原型的屬性和方法，無法訪問父類原型上的屬性和方法。

## 深度掌握 TS 繼承準備 -- 借用構造函數 + 原型鏈繼承組合模式

### 借用構造函數 + 原型鏈繼承組合模式的優勢

1. 具備借用構造函數的有點： 子類可以向父類傳遞參數
2. 具備原型鏈繼承的優點：子類 new 出來的實例對象變量和實例都可以訪問父類原型對象上的屬性和方法

### 借用構造函數 + 原型鏈繼承組合模式的不足

缺點：調用了兩次父類構造函數

1. 進入父類構造函數為屬性賦值，分陪空間，浪費內存
2. 複製導致效率下降一下，關鍵是 new 父類賦的值無意義，出現代碼冗餘，new 子類出來的對象和這些值毫不相干，是通過子類構造函數中的 apply 來向父類構造函數賦值

## 深度掌握 TS 繼承準備 -- 多方法掌握寄生組合繼承【最佳繼承模式】

寄生組合繼承模式 = 借用構造函數 + 寄生繼承

寄生組合繼承沿襲了借用構造函數 + 原型鏈繼承兩個優勢，而且解決了借用構造函數 + 原型鏈繼承調用了兩次父類構造函數的不足，寄生組合繼承模式使用寄生繼承代替了原型鏈繼承。

什麼是寄生繼承？ 就是子類的 prototype 不再指向 new 父類出來的對象空間，而用父類構造函數的原型對象屬性“克隆”了一個對象，讓子類的 prototype 指向這個新對象，很好的避免了借用構造函數 + 原型鏈繼承組合模式調用了兩次父類構造函數為屬性賦值的不足。

5-11
